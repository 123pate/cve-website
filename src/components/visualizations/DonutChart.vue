<template>
  <div class="donut-chart">
    <div class="chart-title">
      <div class="chart-title-inner">
        {{title}}
      </div>
    </div>
    <svg ref="svg"></svg>
  </div><!-- .vertical-bar-chart -->
</template>

<script>
import * as d3 from 'd3';
export default {
  name: 'DonutChart',
  props:[ 
    'title',
    'xLabel',
    'yLabel',
    'width',
    'height',
    'visualizationData'
  ],
  data: function() {
  	return {
  	
  	}
  },
  methods: {
    
  },
  mounted: function() {

// set the dimensions and margins of the graph
var width = 890,
    height = 500,
    margin = 40,
    verticalOffset = 40,
    labelOffset = 30;

// The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
var radius = Math.min(width, height) / 2 - margin

var svg = d3.select(this.$refs.svg)
    .attr("width", width)
    .attr("height", height - verticalOffset * 2)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + (height / 2 - verticalOffset) + ")");

// Create dummy data
var data = {
  "Execute Code": {
    "count": 9,
    "percent": 4
  },
  "Cross-Site Scripting": {
    "count": 60,
    "percent": 24
  },
  "Denial Of Service": {
    "count": 30,
    "percent": 12
  },
  "Overflow": {
    "count": 8,
    "percent": 3
  },
  "Directory Traversal": {
    "count": 12,
    "percent": 5
  },
  "Bypass Something": {
    "count": 13,
    "percent": 5
  },
  "Gain Information": {
    "count": 11,
    "percent": 4
  },
  "Gain Privilege": {
    "count": 18,
    "percent": 7
  },
  "SQL Injection": {
    "count": 38,
    "percent": 16
  },
  "File Inclusion": {
    "count": 12,
    "percent": 5
  },
  "Memory Corruption": {
    "count": 13,
    "percent": 5
  },
  "Cross-Site Request Forgery": {
    "count": 7,
    "percent": 3
  },
  "HTTP Response Splitting": {
    "count": 14,
    "percent": 6
  }
};

// set the color scale
var max = d3.max(Object.values(data).map(function(d){return d.count}));
var color = d3.scaleSequential().domain([-200,(max + 20)])
  .interpolator(d3.interpolateGreys);


// var color = d3.scaleLinear()
//     .domain([0, 1])
//     .range(["red", "green"])

window.color = color;
// var color = d3.scale.linear()
//   .domain(d3.keys(data))
//   .interpolate(d3.interpolateHcl)
//   .range([d3.rgb("#007AFF"), d3.rgb('#FFF500')]);

// Compute the position of each group on the pie:
var pie = d3.pie()
  .sort(null) // Do not sort group by size
  .value(function(d) {
    console.log('>>>', d);
    return d.value.count; })
var data_ready = pie(d3.entries(data))

// The arc generator
var arc = d3.arc()
  .innerRadius(radius * 0.4)         // This is the size of the donut hole
  .outerRadius(radius * 0.75)

// The arc generator
var arcLabel = d3.arc()
  .innerRadius(radius * 0.55)         // This is the starting point of labels
  .outerRadius(radius * 1)

// Another arc that won't be drawn. Just for labels positioning
var outerArc = d3.arc()
  .innerRadius(radius * 0.9)
  .outerRadius(radius * 0.9)

console.log(data_ready);

// Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
svg
  .selectAll('allSlices')
  .data(data_ready)
  .enter()
  .append('path')
  .attr('d', arc)
  .attr('fill', function(d){ 
    console.log(d);
    return (color(d.value)); 
  })
  .attr("stroke", "white")
  .style("stroke-width", "1px")

// Add the polylines between chart and labels:
svg
  .selectAll('allPolylines')
  .data(data_ready)
  .enter()
  .append('polyline')
    .attr("stroke", "black")
    .style("fill", "none")
    .attr("stroke-width", 1)
    .attr('points', function(d) {
      var posA = arcLabel.centroid(d) // line insertion in the slice
      var posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
      var posC = outerArc.centroid(d); // Label position = almost the same as posB
      console.log(posC === posB);
      var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
      posC[0] = radius * 1.13 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
      return [posA, posB, posC]
    })

// Add the polylines between chart and labels:
var labels = svg
  .selectAll('allLabels')
  .data(data_ready);

var labelsEnter = labels.enter()
  .append('g')
    .attr('class', 'donut-label')
    .attr('transform', function(d) {
        var pos = outerArc.centroid(d);
        var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
        pos[0] = radius * 1.2 * (midangle < Math.PI ? 1 : -1);
        return 'translate(' + pos + ')';
    })

labelsEnter
    .append('text')
      .attr('class', 'slice-percent')
      .text( function(d) {return d.data.value.percent + '%'; } )
      .attr('dy', '0.3em')
      .style('text-anchor', function(d) {
          var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
          return (midangle < Math.PI ? 'start' : 'end')
      })


labelsEnter
    .append('text')
      .attr('class', 'slice-label')
      .text( function(d) { return d.data.key } )
      .attr('dy', '0.3em')
      .attr('transform', function(d){
          var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
          return 'translate(' + (midangle < Math.PI ? '' : '-') + labelOffset + ',0)';
      })
      .style('text-anchor', function(d) {
          var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
          return (midangle < Math.PI ? 'start' : 'end')
      })
      
  }
};
</script>

<style lang="scss">
	svg text {
		font-family: 'Roboto';
		font-size: 13px;
		text-transform: uppercase;
	}

  .chart-title-inner {
    max-width: 890px;
    margin: auto;
    text-align: left;
    text-transform: uppercase;
    color: #000;
    font-size: 14px;
    font-weight: 700;
  }

  .donut-label text {
    font-size: 11px;
  }

  .slice-percent {
    font-weight: 900;
  }

</style>
