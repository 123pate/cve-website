<template>
  <div>
    <h1 id="cve-id-title" class="title">
      {{cveFieldList.cveId}}
      <span v-if="cveFieldList.title.length > 0" class="ml-2">{{cveFieldList.title}}</span>
    </h1>
    <div id="cve-view-json" class="container has-text-right ">
      <router-link :to="`api/?action=getCveById&cveId=${this.$store.state.recordData.cveMetadata.cveId}`" target="_blank">
        View JSON
      </router-link>
    </div>
    <div id="cve-cna-container">
      <p v-if="cveFieldList.assigner.length > 0" class="mb-0">
        <span class="has-text-weight-bold" style="text-transform: capitalize;">Assigner: </span>
        <span style="text-transform: capitalize;">{{cveFieldList.assigner}}</span>
      </p>
      <div id="cve-published-updated-dates" class="has-text-grey-dark">
        <span v-if="cveFieldList.datePublicCNA.length > 0">Published: {{cveFieldList.datePublicCNA}}</span>
        <span v-if="cveFieldList.dateUpdatedCNA.length > 0">Updated: {{cveFieldList.dateUpdatedCNA}}</span>
      </div>
      <div id="cve-tags" class="tags is-rounded">
        <span v-for="tag in cveFieldList.tags" :key="tag" class="tag">thu-{{tag}}</span>
      </div>
    </div>
    <div id="cve-desciption">
      <p v-for="description in cveFieldList.descriptions" :key="description">{{description}}</p>
    </div>
    <div id="cve-product-status-container" v-if="cveFieldList.productsStatus.length > 0">
      <h2 class="title is-size-5">Product status</h2>
    </div>
    <div id="cve-credits" v-if="cveFieldList.credits.length > 0">
      <h2 class="title is-size-5">Credits</h2>
      <ul>
        <li v-for="credit in cveFieldList.credits" :key="credit">{{credit}}</li>
      </ul>
    </div>
    <div id="cve-references" v-if="cveFieldList.references.length > 0">
      <p class="title is-size-5">References</p>
      <ul>
        <li v-for="reference in cveFieldList.references" :key="reference.url">
          <span class="icon-text">
            <a :href="reference.url">
              {{ (typeof reference.name !== 'undefined' && reference.name.length > 0) ? reference.name : reference.url }}
              <span class="icon cve-icon-xxs">
                <p id="enewsletter" class="is-hidden">external site</p>
                <font-awesome-icon icon="external-link-alt" aria-labelledby="enewsletter"></font-awesome-icon>
              </span>
            </a>
          </span>
          <p class="tag" :v-if="`${typeof reference.tags}` !== 'undefined'">
            <span v-for="tag in reference.tag" :key="tag">{{tag}}</span>
          </p>
        </li>
      </ul>
    </div>
    <div id="cve-nvd-link">
      <span>View additional information about
        <a :href="NVDUrl" target='_blank'>
          {{ this.$store.state.recordData.cveMetadata.cveId }}
          <span class='icon cve-icon-xxs'>
            <p id='nvd' class='is-hidden'>external site</p>
            <font-awesome-icon icon='external-link-alt' aria-labelledby='nvd'></font-awesome-icon>
          </span>
        </a>
        on NVD.
      </span>
      <p class='cve-help-text'>(Note: The NVD is not operated by the CVE Program)</p>
    </div>
    <!-- add record level dates -->
  </div>
</template>

<script>
import Vue from 'vue';

export default ({
  name: 'PublishedRecord',
  data() {
    return {
      cveRecordFields: ['ID', 'CNA', 'Credits', 'Description', 'Problem Type', 'CNADatePublic', 'CNADateUpdated',
        'References', 'State', 'Tags', 'Title', 'Vendors, Products & Versions'],
      NVDUrl: `https://nvd.nist.gov/view/vuln/detail?vulnId=${this.$store.state.recordData.cveMetadata.cveId}`,
      cveFieldList: {
        cveId: '',
        credits: [],
        descriptions: [],
        productsStatus: [],
        title: '',
        state: '',
        dateUpdatedCna: '',
        assigner: '',
        rejectedReasons: [],
        dateUpdatedCNA: '',
        datePublicCNA: '',
        dateUpdatedCveMetadata: '',
        dateRejectedCveMetadata: '',
        references: [],
        tags: [],
      },
      originalRecordData: this.$store.state.recordData || {},
    };
  },
  methods: {
    initializeFields() {
      const fieldsWithData = {};
      this.cveRecordFields.forEach((field) => {
        const fieldData = this.getContentForField(field);
        if (fieldData) {
          fieldsWithData[field] = fieldData;
        }
      });
      return fieldsWithData;
    },
    getCNA() {
      const value = this.originalRecordData.cveMetadata?.assignerShortName;
      if (this.hasData(value)) {
        this.cveFieldList.assigner = value.replace('_', ' ');
      }
    },
    getCredits() {
      // schema: https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L971-L1015
      // TODO update AWG no tag in credits field
      const value = this.originalRecordData.containers?.cna?.credits;
      if (this.hasData(value)) {
        value.forEach((credit) => {
          if (this.isEnglishLanguage(credit.lang)) {
            this.cveFieldList.credits.push(credit.value);
          }
        });
      }
    },
    getCNADatePublic() {
      const value = this.originalRecordData.containers?.cna?.datePublic;
      if (this.hasData(value)) {
        this.cveFieldList.dateUpdatedCNA = this.getDate(value);
      }
    },
    getCNADateUpdated() {
      const value = this.originalRecordData.containers?.cna?.providerMetadata?.dateUpdated;
      if (this.hasData(value)) {
        this.cveFieldList.datePublicCNA = this.getDate(value);
      }
    },
    getCVEid() {
      const value = this.originalRecordData.cveMetadata?.cveId;
      if (this.hasData(value)) {
        this.cveFieldList.cveId = value;
      } else {
        this.cveFieldList.cveId = this.$store.state.recordData.cveMetadata.cveId; // user-provided CVE ID
      }
    },
    getDescription(recordData) {
      const content = [];
      if (recordData.containers.cna.descriptions.length > 0) {
        recordData.containers.cna.descriptions.forEach((desc) => {
          content.push(desc.value);
        });
      }

      const value = this.originalRecordData.containers?.cna?.descriptions;
      if (this.hasData(value)) {
        value.forEach((desc) => {
          if (this.isEnglishLanguage(desc.lang)) {
            this.cveFieldList.descriptions.push(desc.value);
          }
        });
      }

      return content;
    },
    getProblemType(recordData) {
      const content = ['test', 'test2', 'test3', 'test4', 'test5'];
      if (recordData.containers.cna.problemTypes.length > 0) {
        recordData.containers.cna.problemTypes.forEach((type) => {
          type.descriptions.forEach((desc) => {
            content.push(desc.description);
          });
        });
      }
      return { content, classes: 'tag is-rounded has-text-grey-dark is-capitalized' };
    },
    getReferences() {
      const value = this.originalRecordData.containers?.cna?.references;
      if (this.hasData(value)) {
        Vue.set(this.cveFieldList, 'references', value);
      }
    },
    getState(recordData) {
      return (recordData.cveMetadata.state) ? recordData.cveMetadata.state : '';
    },
    getTags() {
      // TODO remove when done. It's an old function related to Tags UI bug
    },
    getTagsNew() {
      const value = this.originalRecordData.containers?.cna?.tags;
      if (this.hasData(value)) {
        Vue.set(this.cveFieldList, 'tags', value);
      }
    },
    getTitle() {
      const value = this.originalRecordData.containers?.cna?.title;
      if (this.hasData(value)) {
        this.cveFieldList.title = value;
      }
    },
    getAffectedVersions(versions) {
      let content = '';
      versions.forEach((version) => {
        if (version.status === 'affected') {
          content += "<li class='ml-5'>";
          content += 'Still working out what goes here';
          content += '</li>';
        }
      });
      if (content.length > 0) {
        content = `<ul>${content}</ul>`;
      }
      return content;
    },
    getProductsStatus(recordData) {
      const content = [];
      const thisItem = {};
      let contentStr = '';
      thisItem.classes = 'cve-list-no-bullet';
      recordData.containers.cna.affected.forEach((entry) => {
        contentStr = "<span class='has-text-weight-bold'>Vendor: </span>";
        contentStr += (entry.vendor === 'n/a') ? "<span class='is-italic'>Not Specified</span>" : `<span>${entry.vendor}</span>`;

        contentStr += "<ul class='mb-2'>";
        contentStr += (entry.product !== undefined) ? `<li class='cve-list-no-bullet'><span class='has-text-weight-bold'>
          Product: </span><span>${entry.product}</span></li>` : '';
        const affectedVersions = this.getAffectedVersions(entry.versions);
        contentStr += (affectedVersions.length > 0) ? `<li class='cve-list-no-bullet'><span class='has-text-weight-bold'>Versions Affected: </span>${
          affectedVersions}</li>` : '';
        thisItem.content = contentStr;
        content.push(thisItem);
      });

      const value = this.originalRecordData.containers?.cna?.affected;
      if (this.hasData(value)) {
        let prodStatus = {
          vendor: '',
          product: '',
          platforms: [],
          affected: []
        }

        
      }
      return content;
    },
    getContentForField(field) {
      let fieldData = { fieldLabel: field };
      let additionalfieldData = {};
      const { recordData } = this.$store.state;
      switch (field) {
        case 'CNA':
          this.getCNA(recordData);
          break;
        case 'Credits':
          this.getCredits();
          break;
        case 'CNADatePublic':
          this.getCNADatePublic(recordData);
          break;
        case 'CNADateUpdated':
          this.getCNADateUpdated(recordData);
          break;
        case 'ID':
          this.getCVEid();
          break;
        case 'Description':
          this.getDescription(recordData);
          break;
        case 'Problem Type':
          additionalfieldData = this.getProblemType(recordData);
          fieldData.content = additionalfieldData.content;
          fieldData.itemClasses = additionalfieldData.classes;
          break;
        case 'References':
          this.getReferences();
          break;
        case 'State':
          fieldData.content = this.getState(recordData);
          break;
        case 'Tags':
          this.getTagsNew();
          // fieldData.content = [];
          break;
        case 'Title':
          this.getTitle();
          break;
        case 'Vendors, Products & Versions':
          fieldData.content = this.getProductsStatus(recordData);
          break;
        default:
          fieldData = undefined;
      }
      return fieldData;
    },
    hasData(value) {
      if (typeof value !== 'undefined' && value.length > 0) {
        return true;
      }

      return false;
    },
    isEnglishLanguage(lang) {
      const regex = /^(en)/;
      const isEnglishLanguage = regex.test(lang);

      return isEnglishLanguage;
    },
    getDate(dateTime) {
      const [date] = dateTime.split('T');
      return date;
    },
    toggleRecord() {
      this.$store.commit('updateState', { showJsonRecord: !this.$store.state.showJsonRecord });
    },
  },
   beforeMount(){
    this.initializeFields();
 },
});
</script>

// TODO Styling is not applying to headers
<style lang="scss">
@import '@/assets/style/globals.scss';
@import 'bulma';
</style>
